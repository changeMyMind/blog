#### 1.缓存穿透

概念：一直访问一些不存在的key，直接命中到数据库中

解决方案：

- 在没有缓存的前提下访问数据库后，如果还是没有查询到相应数据 可以返回一个固定的内容为空的对象(对象本身不为null 而且是静态唯一的对象 因为每个缓存的方法的返回对象不是一样的 可以返回不同的对象 但是每个方法返回的一定是同一个 对象)
- 采用布隆过滤器，使用一个足够大的bitmap，用于存储可能访问的key，不存在的key直接被过滤；`说实话这个老子非常不认同不知道大厂怎么玩的 一点实用性都没有 神马流程都不给 就这一句话 怎么玩`

#### 2.缓存击穿

概念：一个key 在同一时间或一段时间 被大量访问(大量就是 数据请求非常非常多) `限流还不让做` 做同一个ip的同一个请求做限流 总没问题吧

解决方案：

- 分布式锁 一般都有失效时间
- 提前的分布式锁 在value中设置一个过期时间 这个过期时间比key的失效时间小 具体小多少 自己想吧 我没实际经验 等到查询这个key的value中对应的值的时间小于当前时间，使用分布式锁，重新设置key的失效时间

```java
// 伪代码哈 每次设置nx的时候 默认都有自己的缓存时间的哈 我只是没写 懒得写
v = redis.get(key);  
if (v == null) {  
  
    if (redis.setNx(key_nx, 3 * 60 * 1000)) {  
        value = db.get(key); 
      // 此处value 动点手脚 设置过期时间之前的一段时间 赋值到value中 -> v
        redis.set(key, v, KEY_TIMEOUT*2);  
        redis.delete(key_nx);  
    } else {  
        sleep(50);  
        retry();  
    }  
} else {  
    if (v.timeout <= now()) {  
        if (redis.add(key_nx, 3 * 60 * 1000) == true) {  
            // extend the timeout for other threads  
            v.timeout += 3 * 60 * 1000;  
            // 延长改key的失效时间
            redis.set(key, v, KEY_TIMEOUT*4);  
  
            // load the latest value from db  
            v = db.get(key);  
            v.timeout = KEY_TIMEOUT;  
            redis.set(key, v, KEY_TIMEOUT * 2);  
            redis.delete(key_nx);  
        } else {  
            sleep(50);  
            retry();  
        }  
    }  
}
return v
```

- 永远不失效 没看懂说实话 感觉就是 分布式锁 只不过用了线程池执行而已 完全get不到其中的点 而且如果大量线程过来了tmd不就是线程不能执行了吗 线程池的线程池满了的话的默认策略tmd是直接不处理好不好
- 资源保护：用hystrix 感觉是沙雕吧 都说不愿意要限流 你熔断是几个意思 没脑子 一般都用第二种

总结：再load db的时候直接加分布式锁就行了 bb那么多 还不如一句总结的到位 而且本来就应该这么做 大厂有谁不这么做的？而且很多都是网关 nginx 然后分布式发送 感觉量上去了 扩充机子啊 又不是你的钱 只要不乱搞不就行了吗 无趣 `但是总有些公司为了省事 使用了一些注解 比如@Cacheable这些所以重建缓存的分布式锁就不好加了`

#### 3.缓存雪崩

概念：就是一段时间内 访问的key 全部访问到了db 没有缓存拦截 导致数据库崩溃

解决方案：

- 缓存的失效时间设置的时候直接使用随机值 比如失效时间5天 我让他5天过0到半天内 再失效 这样可以避免通一个key的失效时间 同理其他key 失效也会有相应的差值 可以避免一部分的雪崩效应
- `目前我也就会这么一种了不要笑我了 我菜我快乐`

